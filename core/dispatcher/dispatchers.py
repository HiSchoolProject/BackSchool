# -*- coding: utf-8 -*-
#
# Copyright (C) 2017 The HiSchool! Project
#
# This file is part of HiSchool!.
#
# HiSchool! is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# HiSchool! is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with HiSchool!.  If not, see <http://www.gnu.org/licenses/>.
"""Declare the platform dispatchers used to transfer requests to their correct modules using the URL."""
from importlib import import_module

from django.conf.urls import include
from django.conf.urls import url


class Dispatcher():
    """
    Provide a generic definition of a dispatcher.

    A Dispatcher should be used to generate a list of django.urls.url() that corresponds to the state of the server.
    """

    urls = []
    """An array of URLs generated by the dispatcher."""


class APIDispatcher(Dispatcher):
    """
    Define a list of API routes that can be used for a given application.

    This dispatcher will load and look for a variable named 'apiurls' in the module <application_name>.urls.
    This variable is then used to generate API routes.

    The 'apiurls' variable should be an array of tuples where each tuple contains an iterable of routes for a
    specific API version as the first value and the API version as the second value.

    Example:
    >>> apiurls = [(<urls_for_v1>, 1), (<urls_for_v2>, 2)]
    """

    def __init__(self, applications, versions=None):
        """
        Instanciate a new ApplicationAPIDispatcher that inherits from 'Dispatcher'.

        This dispatcher will attempt to load the urls module of the given applications and then use the
        apipatterns iterable to get a list of routes.

        When 'versions' is specified, the dispatcher will only retain the routes that corresponds to an API having one
        of the given versions.
        """
        if applications is None:
            raise ValueError('An application name should be given for this dispatcher to work')

        super().__init__()
        self.__applications = applications
        self.__accepted_versions = versions

        self.load_urls()

    def scan_module(self, application):
        """
        Try to load the urls module contained in the given application package.

        If such module is found, returns the iterable of API URLs declared by the application.
        """
        try:
            module = import_module('.urls', application)
            if hasattr(module, 'apiurls'):
                return module.apiurls
            else:
                return []
        except ImportError as e:
            return []

    def import_application_urls(self, application, api_urls):
        """Construct an array of urls for the object."""
        for (urls, version) in api_urls:
            if (self.__accepted_versions is None or version in self.__accepted_versions):
                if version not in self.__url_versions:
                    self.__url_versions[version] = []

                self.__url_versions[version].append(url('^{}/'.format(application), include(urls)))

    def generate_version_includes(self):
        """
        Create an iterable of urls.

        Each url matches an API version and includes sub-urls extracted from
        every the extensions offering API endpoints for this version.

        The final iterable is stored in the 'urls' attribute.
        """
        self.urls = []
        for version in self.__url_versions:
            self.urls.append(url('^v{}/'.format(version), include(self.__url_versions[version])))

    def load_urls(self):
        """
        Load API urls form the given applications and versions.

        The generated urls are then stored as self.urls.
        """
        self.__url_versions = {}

        for application in self.__applications:
            self.import_application_urls(application, self.scan_module(application))

        self.generate_version_includes()
